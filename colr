#!/usr/bin/env zsh

self=$0:t


# ------------------------------------------------------------- #
#                              help                             #
# ------------------------------------------------------------- #

[[ $1 = '-h' || $1 = --help ]] &&
{
echo
read -erd '' <<'EOF' | sed -E 's \$0 '"$0 "
NAME

  $0 - colorize stdin or a stdout of a program


SYNOPSIS

  $0 [program [args]] [ [--colorDef | -_c] [regex grepArg ansicolor] [..]]


DESCRIPTION

  If no `program` and optional `args` is provided, stdin is colorized.

  If no `--colorDef` argument + following formatting rules triples is provided, some default formatting rules are applied.


OPTIONS

  -_c, --colorDef
  

ENVIRONMENT

  COLR_COLLECT
    If non-null, then with the `program` argument form, `programs` stderr is immediately merged with its stdout, after which the merged output will undergo the colorization process. The colorized output is then written to $0-s stdout. This is intended to avoid stdout/stderr out-of-order problems.

EXAMPLES

  Will use default formatting rules, will produce identical output:

    $0 print -l message error warning

    print -l message error warning | $0
    
    { echo message
      echo error
      echo warning >&2
    } | $0

  Will colorize kernel version in blue and any HH:MM:SS times in green:

    $0 uname -a --colorDef \
      'kernel version [\d\.]+'  -i  '38;5;117' \
      ' (\d\d|:)+ '             ''  '38;5;119'

  Illustrating COLR_COLLECT:

    { COLR_COLLECT='' \
      colr zsh -c 'echo warning-text >&2' \
    
      COLR_COLLECT='1' \
      colr zsh -c 'echo warning-text >&2'
    
    } | sed -E 's/$/  **on stdout**/'

    # output ("warning" colored on both lines):
    #   warning-text
    #   warning-text  **on stdout**

EOF
echo
exit 0
}


# ------------------------------------------------------------- #
#                         implementation                        #
# ------------------------------------------------------------- #

setopt   local_options NO_unset pipefail NO_monitor NO_glob

# internal parameters:
DBG=0
DBG_BYPASS=0

__grep=( ggrep --color=always --line-buffered )

clrDefDefault=( 
  ^error                      -i  '01;31'  # red
  ^warning                    -i  '01;33'  # yellow
  )

# parse arguments:
cmdArr=()
clrDef=()
while (( $#>0 )) && [[ ! $1 =~ '--colorDef|-_c' ]]; do cmdArr+=$1; shift; done
while (( $#>0 )) && [[   $1 =~ '--colorDef|-_c' ]]; do :         ; shift; done
while (( $#>0 ))                                  ; do clrDef+=$1; shift; done


# fix + check colors array:
(( $#clrDef == 0 )) && clrDef=("${(@)clrDefDefault}")
(( (${#clrDef} % 3) != 0 )) &&
  { >&2 echo "$self: colorDef: ${#clrDef} elements, expected multiple of 3"
    exit 1
  }

# main function:
colorize() {
  if (( $# >= 3 ))
  then
    local    pat="($1)|$"
    local -a opts=( ${(s[ ])2} )
    local    color=$3
    shift 3
    GREP_COLORS="ms=$color"           \
      $__grep "${opts[@]}" -P "$pat"  \
      | colorize "$@"
  else
    cat -u
    (( $# > 0 )) && >&2 echo "$self: warning: unexpected colorDef element"
  fi
  }

if (( DBG ))
then  typeset -p 1 cmdArr
      typeset -p 1 clrDef
fi
if (( DBG_BYPASS ))
then  "${(@)cmdArr}"
      exit 0
fi


# ------------------------------------------------------------- #
#                          main program                         #
# ------------------------------------------------------------- #

zmodload zsh/datetime
local rnd=$(( (epochtime[2]/1000) % 100 ))

local P_stdout=/tmp/P_${rnd}_${self}_stdout
local P_stdERR=/tmp/P_${rnd}_${self}_stdERR

[[ ${COLR_COLLECT-} ]] && __col() true  \
                       || __col() false

(( DBG )) && { __col && <<<collect_yes || <<<collect_NO }


{ rm -f  $P_stdout(Np) $P_stdERR(Np)

               mkfifo $P_stdout
  ! __col &&   mkfifo $P_stdERR

               < $P_stdout colorize "${clrDef[@]}"     &
  ! __col &&   < $P_stdERR colorize "${clrDef[@]}" >&2 &

  ! __col &&   local cmdErrTo=$P_stdERR \
          ||   local cmdErrTo=$P_stdout
  
  
  (( 0 )) && {
    local cmd
    printf 'cmd   :   %s\n' "${(@)cmdArr:-cat}"
    printf 'cmd q :   %s\n' "${(@q)cmdArr:-cat}"
    }


  eval "${(@q)cmdArr:-cat}" 1>$P_stdout 2>$cmdErrTo


} always {
  wait
  sleep 0.3
  () { setopt glob; rm -f $P_stdout(Np) $P_stdERR(Np)
     }

}

